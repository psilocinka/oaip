# oaip

3 задание (5 вариант)
Дано бинарное дерево. В узлах бинарного дерева хранятся слова.
Определить поддерево максимальной длины, в качестве ключа используется
целое число. В найденном поддереве найти слово минимальной длины.

Алгоритм Шагов:
1. Включить необходимые заголовочные файлы: iostream, string, climits, Windows.h.
2. Определить структуру Node для представления узла дерева.
   - Структура должна содержать поля: key (целое число), word (строка), left (указатель на левое поддерево) и right (указатель на правое поддерево).
   - Определить функцию newNode, которая создает новый узел и инициализирует его поля.
3. Определить функцию insert, которая вставляет новый узел в дерево.
   - Функция должна принимать указатель на текущий узел и значения ключа и слова нового узла.
   - Если текущий узел равен nullptr, создать новый узел с помощью функции newNode и вернуть его.
   - Если ключ нового узла меньше ключа текущего узла, рекурсивно вызвать insert для левого поддерева и обновить указатель на левое поддерево текущего узла.
   - Если ключ нового узла больше ключа текущего узла, рекурсивно вызвать insert для правого поддерева и обновить указатель на правое поддерево текущего узла.
   - Вернуть указатель на текущий узел.
4. Определить функцию height, которая вычисляет высоту дерева.
   - Функция должна принимать указатель на корень дерева.
   - Если указатель равен nullptr, вернуть 0.
   - Иначе:
     - Рекурсивно вызвать height для левого поддерева и сохранить результат в lheight.
     - Рекурсивно вызвать height для правого поддерева и сохранить результат в rheight.
     - Вернуть максимум из lheight и rheight, увеличенный на 1 (текущий уровень).
5. Определить функцию minWordInLevel, которая находит минимальное слово на заданном уровне дерева.
   - Функция должна принимать указатель на текущий узел, уровень level.
   - Если указатель равен nullptr, вернуть пустую строку.
   - Если level равен 1, вернуть слово текущего узла.
   - Если level больше 1, рекурсивно вызвать minWordInLevel для левого поддерева с уровнем уменьшенным на 1 и сохранить результат в leftWord.
   - Рекурсивно вызвать minWordInLevel для правого поддерева с уровнем уменьшенным на 1 и сохранить результат в rightWord.
   - Если leftWord пустая строка, вернуть rightWord.

4 задание (5 вариант)
Написать программу формирования ОПЗ и расчета полученного
выражения. Разработать удобный интерфейс ввода исходных данных и вывода
результатов. Язык программирования С++. Работу программы проверить на
конкретном примере (табл. 1).

Алгоритм шагов:
1. Включить необходимые заголовочные файлы: iostream, stack, sstream, cmath.
2. Использовать пространство имен std для удобства.
3. Определить функцию precedence, которая принимает оператор и возвращает его приоритет. Операторам "+" и "-" присваивается приоритет 1, операторам "*" и "/" - приоритет 2, все остальные операторы получают приоритет 0.
4. Определить функцию infix_to_postfix, которая принимает входное выражение в инфиксной форме и возвращает его эквивалент в постфиксной форме. Внутри функции выполнить следующие действия:
   - Создать пустой стек символов stack и пустую строку postfix для хранения постфиксного выражения.
   - Пройти по каждому символу c во входном выражении:
     - Если c является цифрой или точкой, добавить его в postfix.
     - Если c равен "(", поместить его в стек.
     - Если c равен ")", выполнить следующее:
       - Пока стек не пуст и верхний элемент стека не является "(", добавить пробел и верхний элемент стека в postfix, а затем удалить верхний элемент из стека.
       - Удалить "(". 
     - Если c равен "+", "-", "*" или "/", выполнить следующее:
       - Добавить пробел в postfix.
       - Пока стек не пуст и приоритет верхнего элемента стека больше или равен приоритету c, добавить верхний элемент стека, пробел и удалить его из стека.
       - Поместить c в стек.
   - Пока стек не пуст, добавить пробел и верхний элемент стека в postfix, а затем удалить верхний элемент из стека.
   - Вернуть значение postfix.
5. Определить функцию evaluate_rpn, которая принимает постфиксное выражение и вычисляет его значение. Внутри функции выполнить следующие действия:
   - Создать пустой стек чисел stack и создать объект stringstream ss для разбора постфиксного выражения.
   - Пока можно получить токен из ss с использованием разделителя пробела:
     - Если токен является оператором "+", "-", "*" или "/", выполнить следующее:
       - Получить правый операнд из вершины стека, удалить его из стека.
       - Получить левый операнд из вершины стека, удалить его из стека.
       - Выполнить соответствующую операцию на левом и правом операндах и поместить результат в стек

5 задание (5 вариант)
А. Ввести массив из п целых чисел из заданного диапазона. Создать хеш-
таблицу из М элементов. Осуществить поиск элемента в хеш-таблице. Вы-
вести на экран исходный массив, хеш-таблицу и результат поиска. Задание выбрать в соответствии с номером варианта в табл. 1.
В. Объявить и ввести массив структур из п элементов. Создать хеш-
таблицу из М элементов. Осуществить поиск элемента по ключу в хеш-
таблице. Вывести на экран исходный массив, хеш-таблицу и все поля найденной структуры. Задание выбрать в соответствии с номером
варианта в табл. 2.

Алгоритм шагов:
ПЕРВАЯ ЗАДАЧА
Алгоритм шагов для данной программы выглядит следующим образом:

1. Включить необходимые заголовочные файлы: iostream, ctime, climits.
2. Определить константу HASH_TABLE_SIZE для размера хеш-таблицы и константу ARRAY_SIZE для размера исходного массива.
3. Определить функцию hashFunction, которая принимает ключ и возвращает индекс в хеш-таблице.
   - Функция должна использовать остаток от деления ключа на размер хеш-таблицы.
4. Определить функцию linearProbing, которая выполняет линейное пробирование и вставляет ключ в хеш-таблицу.
   - Функция должна принимать хеш-таблицу и ключ.
   - Вычислить индекс с помощью функции hashFunction.
   - Пока значение в ячейке с текущим индексом не равно INT_MIN, увеличивать индекс на 1 по модулю размера хеш-таблицы.
   - Вставить ключ в ячейку с текущим индексом.
5. Определить функцию search, которая выполняет поиск ключа в хеш-таблице.
   - Функция должна принимать хеш-таблицу и ключ.
   - Вычислить индекс с помощью функции hashFunction.
   - Пока значение в ячейке с текущим индексом не равно INT_MIN:
     - Если значение в ячейке равно ключу, вернуть текущий индекс.
     - Увеличить индекс на 1 по модулю размера хеш-таблицы.
   - Если цикл завершился, значит ключ не найден, вернуть -1.
6. В функции main:
   - Установить русскую локаль для корректного отображения текста.
   - Инициализировать генератор случайных чисел с помощью текущего времени.
   - Объявить и инициализировать массив arr размером ARRAY_SIZE и хеш-таблицу hashTable размером HASH_TABLE_SIZE, заполнив все элементы значением INT_MIN.
   - Сгенерировать случайные числа и сохранить их в массив arr.
   - Произвести линейное пробирование для каждого элемента массива arr и вставить их в хеш-таблицу hashTable.
   - Вывести исходный массив arr.
   - Вывести хеш-таблицу hashTable, заменяя пустые ячейки символом "_".
   - Случайным образом выбрать значение value из массива arr.
   - Выполнить поиск значения value в хеш-таблице с помощью функции search и сохранить результат в переменную index.
   - Если значение index не равно -1, вывести сообщение о найденном значении и его индексе.

ВТОРАЯ ЗАДАЧА
Алгоритм шагов для данной программы выглядит следующим образом:

1. Включить необходимые заголовочные файлы: iostream, cstring, Windows.h.
2. Определить константу HASH_TABLE_SIZE для размера хеш-таблицы и константу ARRAY_SIZE для размера массива книг.
3. Определить структуру Book, содержащую поля для названия книги (символьный массив), количества страниц и года издания.
4. Определить функцию hashFunction, которая принимает количество страниц книги и возвращает индекс в хеш-таблице.
   - Функция должна использовать остаток от деления количества страниц на размер хеш-таблицы.
5. Определить функцию quadraticProbing, которая выполняет квадратичное пробирование и вставляет книгу в хеш-таблицу.
   - Функция должна принимать хеш-таблицу и книгу.
   - Вычислить индекс с помощью функции hashFunction.
   - Использовать переменную i для увеличения шага пробирования.
   - Пока значение в ячейке с текущим индексом не является пустым, увеличивать индекс на i^2 по модулю размера хеш-таблицы и увеличивать i на 1.
   - Вставить книгу в ячейку с текущим индексом хеш-таблицы.
6. Определить функцию search, которая выполняет поиск книги по количеству страниц в хеш-таблице.
   - Функция должна принимать хеш-таблицу и количество страниц.
   - Вычислить индекс с помощью функции hashFunction.
   - Использовать переменную i для увеличения шага пробирования.
   - Пока значение в ячейке с текущим индексом не является пустым:
     - Если количество страниц в книге равно искомому количеству страниц, вернуть текущий индекс.
     - Увеличить индекс на i^2 по модулю размера хеш-таблицы и увеличивать i на 1.
   - Если цикл завершился, значит книга не найдена, вернуть -1.
7. В функции main:
   - Установить русскую локаль для корректного отображения текста в консоли.
   - Установить кодировку консоли для работы с русскими символами.
   - Объявить массив books размером ARRAY_SIZE для хранения книг и хеш-таблицу hashTable размером HASH_TABLE_SIZE.
   - Инициализировать хеш-таблицу, устанавливая пустые значения для каждой ячейки.
